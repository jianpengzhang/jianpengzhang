<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Keystone Mitaka Tenants 分页代码下载]]></title>
      <url>%2F2017%2F02%2F26%2F2017022606%2F</url>
      <content type="text"><![CDATA[您的小额赞助，鼓励作者开发更多实用的功能：扫一扫下方二维码，完成支付，并把截图发送给QQ：3477447625，将获取百度云下载密码，百度云下载地址： http://pan.baidu.com/s/1bo4iPEf￼]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OpenStack Mitaka keystone 分页（pagination）实现]]></title>
      <url>%2F2017%2F02%2F26%2F2017022605%2F</url>
      <content type="text"><![CDATA[一、写在前面这篇文章主要介绍了OpenStack Mitaka Identity (keystone) 分页的实现，实现的方式比较简单暴力(扩展Keystone API)，但目前已是作者想到的快速便捷实现的一种方式，如果各位有更优的现实方式请告知，相互进行技术交流，因为时间仓促以及个人理解有限，固有错误的地方请指出，谢谢！ 如果转载，请保留作者信息。邮箱地址：jpzhang.ht@gmail.com个人博客：http://www.smallartisan.site/CSDN博客：http://blog.csdn.net/u011521019代码下载：http://www.smallartisan.site/?p=97￼ 二、Keystone 分页历史Identity (keystone) 分页早在2013年的时候就被提出，记忆中openstack开发峰会中还专门进行了讨论，时间过的太久记不起来，也懒得查找资料来说明历史，唯独找到https://blueprints.launchpad.net/keystone/+spec/pagination-backend-support，这个页面记录着在13年的时候扩展Identity (keystone)，尽可能提高伸缩和性能被当作为一个Blueprints记录着，其中https://blueprints.launchpad.net/keystone/+spec/filtering-backend-support表示这个Blueprints在14年有一个里程碑的进展，但是从代码层面看，并没有真正实现底层代码的分页。 https://blueprints.launchpad.net/keystone/+spec/pagination说明：分页的当前状态是未知的。本该在IceHouse summit会议 “kill pagination” 但是它从未兑现。分页依旧是残留的。 https://blueprints.launchpad.net/keystone/+spec/user-list-pagination 可以看到分页在2015年-09-11重新被提出，但是通过Blueprint information没有里程碑的进展， 目前分页的三个问题：1、Marker+Limit(例如:实现“向前”分页)构建一个用户界面分页是不合适的。2、分页扩展性不好3、OpenStack提供的Api过滤功能并不是很好用。 Pagaination 反对的论点： 1.分页被滥用。例如，如果后端、配置不正确，可能需要很长的时间来满足用户通用的查询以及可能会返回大量的数据。2.分页可能会伤害用户体验。请参阅 然而这不是分页根本性的障碍，从 API 的角度，分页是必要和有用的。 三、分页实现项目列表代码分析这里通过devstack部署的Mitaka版本来进行代码分析，默认部署完成之后keystone API 接口用的是V3， 但是简单看了下代码，horizon中对项目（tenants）连最基本的分页都没有，就决定不再基于V3接口代码下来讲解，通过对V2.0接口的代码来说明，因为V2.0接口中至少简单实现了tenants的部分分页代码，基于此来说明久更加方便易懂，读者也只需要掌握了基本的思路，想扩展其他功能列表的分页也比较轻易的事情。这里就允许自己偷个懒。V3接口项目列表（已在设置中设置每页显示2条记录）：￼你可以看到设置每页显示条目根本没有起作用。 V2.0 接口项目列表（已在设置中设置每页显示2条记录）：￼对比就比较明显，使用2.0的keystone接口，至少“前进“－&gt;下一页的按钮出来，能够进行分页，但是马上你会发现只有“前进”没有“后退”，不能翻看上一页的数据，不得不说openstack中的分页真是蛋疼。如果你和我一样，默认的API接口是3，通过一下的方式就可以进行切换。 12345678/openstack_dashboard/local/local_settings.pyWEBROOT=&quot;/&quot;COMPRESS_OFFLINE=TrueOPENSTACK_KEYSTONE_DEFAULT_ROLE=&quot;Member&quot;OPENSTACK_HOST=&quot;192.168.31.235&quot;# 注意，这里一定要写2.0OPENSTACK_API_VERSIONS=&#123;&quot;identity&quot;:2.0&#125;OPENSTACK_KEYSTONE_URL=&quot;http://192.168.31.235:5000/v2.0&quot; OK，keystone配置成V2.0的接口，接下去我们就来梳理下，“向前”实现的方式。 123456/openstack_dashboard/dashboards/identity/projects/urls.pyurlpatterns = patterns( &apos;&apos;, url(r&apos;^$&apos;, views.IndexView.as_view(), name=&apos;index&apos;), ...... 通过urls路由映射，可以查看出，项目（tenants）页面请求调用的方法是views.IndexView方法。 代码有点长： 123456789101112131415161718192021222324252627282930313233343536/openstack_dashboard/dashboards/identity/projects/views.pyclass IndexView(tables.DataTableView): table_class = project_tables.TenantsTable template_name = &apos;identity/projects/index.html&apos; page_title = _(&quot;Projects&quot;) def has_more_data(self, table): # 返回True/False，table根据返回值显示是否有下一页的按钮链接 return self._more def get_data(self): tenants = [] # 获取request.GET对象中“tenant_marker”值，该值指的是当前页面最后一条tenant的ID值 marker = self.request.GET.get( project_tables.TenantsTable._meta.pagination_param, None) # 设置默认没有下一页 self._more = False # 权限判断，判断当前用户时候有identity:list_projects、list_user_projects权限， if policy.check(((&quot;identity&quot;, &quot;identity:list_projects&quot;),), self.request): domain_context = api.keystone.get_effective_domain_id(self.request) # paginate 参数用来设置是否采用分页 try: tenants, self._more = api.keystone.tenant_list( self.request, domain=domain_context, paginate=True, marker=marker) except Exception: exceptions.handle(self.request, _(&quot;Unable to retrieve project list.&quot;)) elif policy.check(((&quot;identity&quot;, &quot;identity:list_user_projects&quot;),), self.request):...... 重点关注IndexView类中的has_more_data、get_data方法：has_more_data：返回self._more值，该值根据返回的数据数量确定下一页是否有数据，如果有数据该值为True，即页面上显示“向前”，当然相对应的还有has_prev_data方法，这在下文进行扩展的时候具体说明。get_data：该方法用来获取项目（tenants）页面tables中显示的数据信息。 接下去重点看下get_data方法，其中： 1234......marker = self.request.GET.get( project_tables.TenantsTable._meta.pagination_param, None)...... 这段代码用来从request.GET对象中获取 “project_tables.TenantsTable._meta.pagination_param”，如果没有该值即返回None，那么这里代表的是什么值呢？一点点拆分这部分代码，project_tables：openstack_dashboard.dashboards.identity.projects.tables.py -&gt; class TenantsTable()该table类定义项目（tenants）页面table。_meta：指的是TenantsTable中的元类(metaclass),class Meta(object)即： 12345678910class Meta(object): name = &quot;tenants&quot; verbose_name = _(&quot;Projects&quot;) row_class = UpdateRow row_actions = (UpdateMembersLink, UpdateGroupsLink, UpdateProject, UsageLink, ModifyQuotas, DeleteTenantsAction, RescopeTokenToProject) table_actions = (TenantFilterAction, CreateProject, DeleteTenantsAction) pagination_param = &quot;tenant_marker&quot; pagination_param:即class Meta(object)中的属性，属性值是”tenant_marker”，到了这里就比较清楚了， 123456marker = self.request.GET.get( project_tables.TenantsTable._meta.pagination_param, None) 指的是： marker = self.request.GET.get(&quot;tenant_marker&quot;, None) 经过调试，marker其实获取的是用户点击下一页的时候request.GET中tenant ID值，即浏览器地址中看到的“http://192.168.31.235:8001/identity/?tenant_marker=64d50f68d69b451c8653296db25d9c86”，这个Tenant ID指的是当前页面最后一条tenant 的ID，关于这个ID有什么作用后面会具体说明。 调用api.keystone.tenant_list方法获取tenant list 数据，传入参数paginate布尔值，代码是否进行分页，返回tenants、 self._more，self._more布尔值表示是否有更多的数据需要下一页显示。 12345tenants, self._more = api.keystone.tenant_list( self.request, domain=domain_context, paginate=True, marker=marker) 调用api.keystone.tenant_list方法获取数据，代码具体如下： 1234567891011121314151617181920212223242526272829303132333435363738394041openstack_dashboard/api/keystone.py:def tenant_list(request, paginate=False, marker=None, domain=None, user=None, admin=True, filters=None): manager = VERSIONS.get_project_manager(request, admin=admin) # 获取每页显示多少条数据 page_size = utils.get_page_size(request) limit = None # 判断是否进行分页，如果分页从底层抓取数据的数据的时候夺取一条，用来判断是否还有更多的数据，用于判断是否显示下一页 if paginate: limit = page_size + 1 has_more_data = False # if requesting the projects for the current user, # return the list from the cache if user == request.user.id: tenants = request.user.authorized_tenants elif VERSIONS.active &lt; 3: # 判断keystone API 接口版本，这里使用的是2.0接口 tenants = manager.list(limit, marker) # 判断获取的数据是否比每页显示的数据多，如果获取的数据多于每页需要显示的数据，即表示还有下一页数据展示 if paginate and len(tenants) &gt; page_size: # 按照用户配置显示制定数量的数据，移除多抓取出来的一条数据 tenants.pop(-1) # 设置下一页数据显示为true， has_more_data = True # V3 API else: domain_id = get_effective_domain_id(request) kwargs = &#123; &quot;domain&quot;: domain_id, &quot;user&quot;: user &#125; if filters is not None: kwargs.update(filters) tenants = manager.list(**kwargs) return tenants, has_more_data 这里调用“tenants = manager.list(limit, marker)”，传入需要参数limit、marker。limit：每页显示几条数据，抓取数据的时候多抓取一条，用于判断是否还有更多的数据，多取一条数据的目的为了判断显示“上一页”、“下一页”。marker：这个值很有意思，这是horizon默认分页采用的原理，marker表示当前页面第一条数据或者最后一条数据的ID值，如果点击的是下一页，这个值既是当前页面最后一条记录的ID值，该值传入到keystone中，底层代码判断该条数据在数据库中的位置，下一页的数据就从这条数据所在的位置开始取，取指定数量的数据。如果点击的是上一页，这个数值表示的是当前页面第一条数据的ID，用处也是一样，用于告知底层取下一页的数据从什么位置开始取。 调用keystoneclient的代码发起request请求，获取数据： 123456789101112131415161718192021222324252627282930313233keystoneclient/v2_0/tenants.py:def list(self, limit=None, marker=None): &quot;&quot;&quot;Get a list of tenants. :param integer limit: maximum number to return. (optional) :param string marker: use when specifying a limit and making multiple calls for querying. (optional) :rtype: list of :class:`Tenant` &quot;&quot;&quot; # 组拼参数 params = &#123;&#125; if limit: params[&apos;limit&apos;] = limit if marker: params[&apos;marker&apos;] = marker query = &quot;&quot; if params: query = &quot;?&quot; + urllib.parse.urlencode(params) # NOTE(jamielennox): try doing a regular admin query first. If there is # no endpoint that can satisfy the request (eg an unscoped token) then # issue it against the auth_url. try: tenant_list = self._list(&apos;/tenants%s&apos; % query, &apos;tenants&apos;) except exceptions.EndpointNotFound: endpoint_filter = &#123;&apos;interface&apos;: auth.AUTH_INTERFACE&#125; tenant_list = self._list(&apos;/tenants%s&apos; % query, &apos;tenants&apos;, endpoint_filter=endpoint_filter) return tenant_list 这一块没什么好讲，组拼请求参数，发起GET请求至nova api，用于获取数据，没有什么好讲，每个API接口调用都是一样的。 接下来我们具体来看下keystone组件中对于tenant请求的处理， 12345678910111213keystone/keystone/assignment/routers.pyclass Public(wsgi.ComposableRouter): def add_routes(self, mapper): # 定义处理的控制器类 tenant_controller = controllers.TenantAssignment() # 映射，将通过“GET”方式以及请求地址带上“/tenants”发送的请求绑定到处理控制器tenant_controller。 mapper.connect(&apos;/tenants&apos;, controller=tenant_controller, # 指定控制器中处理的函数 action=&apos;get_projects_for_token&apos;, # 指定请求发送的方式 conditions=dict(method=[&apos;GET&apos;])) 在“Public”类中的add_routes函数中清楚的定义了，当API请求地址为“/tenants”时并且请求是以“GET”的方式发送过来，调用控制器为tenant_controller中的“get_projects_for_token”函数，tenant_controller控制器指的是controllers.TenantAssignment()，至于如何加载这个路由规则后续的文章讲逐步说明。 控制器处理函数： 12345678910111213141516171819202122232425262728/keystone/keystone/assignment/controllers.py@dependency.requires(&apos;assignment_api&apos;, &apos;identity_api&apos;, &apos;token_provider_api&apos;)class TenantAssignment(controller.V2Controller): &quot;&quot;&quot;V2 Tenant api处理类。&quot;&quot;&quot; @controller.v2_auth_deprecated def get_projects_for_token(self, context, **kw): &quot;&quot;&quot;获取基于用于认证令牌令牌有效的租户。 从上下文获取令牌，验证它并得到有效租户令牌中的用户。 &quot;&quot;&quot; token_ref = utils.get_token_ref(context) # 获取tenant 列表 tenant_refs = ( self.assignment_api.list_projects_for_user(token_ref.user_id)) # project_ref从V3到V2转换， 该方法只适用于project_refs从2.0控制器返回 # 如果ref是列表类型，我们将通过每个元素反复做转换。 tenant_refs = [self.v3_to_v2_project(ref) for ref in tenant_refs if ref[&apos;domain_id&apos;] == CONF.identity.default_domain_id] params = &#123; &apos;limit&apos;: context[&apos;query_string&apos;].get(&apos;limit&apos;), &apos;marker&apos;: context[&apos;query_string&apos;].get(&apos;marker&apos;), &#125; # 格式v2样式项目列表,包括标记/限制。 return self.format_project_list(tenant_refs, **params) 这里涉及比较重要的三个方法调用： 1、/keystone/keystone/assignment/core.py：list_projects_for_user():获取project_ref，即tenants 2、/keystone/keystone/common/controller.py：v3_to_v2_project():project_ref从V3到V2转换。 3、/keystone/keystone/common/controller.py：format_project_list()转换v2样式项目列表,包括标记/限制。 这里重点讲一下1和3， 获取project_ref，即tenants12345678910/keystone/keystone/assignment/core.py# TODO(henry-nash): We might want to consider list limiting this at some # point in the future. def list_projects_for_user(self, user_id, hints=None): assignment_list = self.list_role_assignments( user_id=user_id, effective=True) # Use set() to process the list to remove any duplicates project_ids = list(set([x[&apos;project_id&apos;] for x in assignment_list if x.get(&apos;project_id&apos;)])) return self.resource_api.list_projects_from_ids(list(project_ids)) 这个函数比较复杂，在这里不进行代码分析，后续有用到在具体进行分析，你只需要了解到，这个方法最终将返回tenants 列表。 默认分页的实现让我们回到class TenantAssignment(), 看下：1234567/keystone/keystone/assignment/controllers.py......params = &#123; &apos;limit&apos;: context[&apos;query_string&apos;].get(&apos;limit&apos;), &apos;marker&apos;: context[&apos;query_string&apos;].get(&apos;marker&apos;), &#125; return self.format_project_list(tenant_refs, **params) 这部分代码把分页用到的参数：limit、marker 、以及tenant_refs传入到self.format_project_list() 实现分页,但是可以这里知道Mitaka版本的horizon并没有在把limit、marker 参数传递过来，因此分页并没有起作用。 123456789101112131415161718192021222324252627282930313233343536373839404142keystone/keystone/common/controller.py(384)format_project_list() def format_project_list(self, tenant_refs, **kwargs): &quot;&quot;&quot;Format a v2 style project list, including marker/limits.&quot;&quot;&quot; # 获取horizon传递过来的marker值，该值表示的是上一页最后一条记录的ID值或者最后一条记录的ID值 marker = kwargs.get(&apos;marker&apos;) # 初始化下一页数据或上一个数据从什么位置开始取 first_index = 0 if marker is not None: # 循环确定marker ID表示的记录位置， for (marker_index, tenant) in enumerate(tenant_refs): if tenant[&apos;id&apos;] == marker: # we start pagination after the marker # 通过比对marker值，确定下一页数据或者上一页数据从first_index位置开始取 first_index = marker_index + 1 break else: msg = _(&apos;Marker could not be found&apos;) raise exception.ValidationError(message=msg) # limit 表示取几条记录 limit = kwargs.get(&apos;limit&apos;) last_index = None if limit is not None: try: limit = int(limit) if limit &lt; 0: raise AssertionError() except (ValueError, AssertionError): msg = _(&apos;Invalid limit value&apos;) raise exception.ValidationError(message=msg) # 确定分页取到第几条记录的位置 last_index = first_index + limit # 通过列表切片的形式进行分页，这里可以看到没有实现真正的数据库分页， # 还是一种简单的分页，这种分页比前段分页就是降低了请求返回的数据包大小 tenant_refs = tenant_refs[first_index:last_index] for x in tenant_refs: if &apos;enabled&apos; not in x: x[&apos;enabled&apos;] = True o = &#123;&apos;tenants&apos;: tenant_refs, &apos;tenants_links&apos;: []&#125; return o 具体分析可以看我的代码注释，这一块没有起到正真的分页，只是一种伪分页，没有实现数据库分页机制，在性能上并没有提升多少。 实现项目列表分页OK，说了这么多，接下来我就来讲讲怎么通过扩展API接口来实现项目组列表的分页，时间仓促以及个人理解有限，编码格式可能并不是标准规范请谅解。 Horizon:openstack_dashboard/dashboards/identity/projects/views.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class IndexView(tables.DataTableView):....def has_more_data(self, table): # author: jpzhang.ht@gmail.com # blog: http://www.smallartisan.site/ or http://blog.csdn.net/u011521019 # 返回True/False，table根据返回值显示是否有下一页的按钮链接 return self._moredef has_prev_data(self, table): # author: jpzhang.ht@gmail.com # blog: http://www.smallartisan.site/ or http://blog.csdn.net/u011521019 # 返回True/False，table根据返回值显示是否有上一页的按钮链接 return self._prev....def get_data(self):#获取prev_pagination_param，该值指的是当前页面第一条tenant的ID值 prev_marker = self.request.GET.get( project_tables.TenantsTable._meta.prev_pagination_param, None) if prev_marker is not None: marker = prev_marker else: # 获取request.GET对象中“tenant_marker”值，该值指的是当前页面最后一条tenant的ID值 marker = self.request.GET.get( project_tables.TenantsTable._meta.pagination_param, None) # 根据是否是上一页还是下一页，得到一个布尔值 reversed_order = prev_marker is not None tenants = [] # 权限判断，判断当前用户时候有identity:list_projects、list_user_projects权限， if policy.check(((&quot;identity&quot;, &quot;identity:list_projects&quot;),), self.request): domain_context = api.keystone.get_effective_domain_id(self.request) # paginate 参数用来设置是否采用分页 try: tenants, self._more, self._prev = api.keystone.tenant_list_paged( self.request, domain=domain_context, paginate=True, marker=marker, sort_dir=&apos;asc&apos;, # 排序 sort_key=&apos;id&apos;, # 排序字段 reversed_order=reversed_order) except Exception: self._prev = self._more = False exceptions.handle(self.request, _(&quot;Unable to retrieve project list.&quot;))...... 这块的代码比较简单，def has_more_data(self, table)；def has_prev_data(self, table)定义两个属性值用来表示列表是否有上一页数据还是有下一页数据，根据返回的数据长度来确定，获取N＋1条数据，其中N表示每页显示的数据，每次取数据都多取一条记录用来判断是否有上一页数据还是有下一页数据。 prev_marker／marker用来获取点击上一页或者下一页的时候URL路径上表示的project ID值，这个值用来干什么上面已有介绍，这里不再叙述。 tenant_list_paged(),这个方法是自己定义的主要用来调用keystoneclient发起request请求，向keystone获取project的数据。其中有几个参数在这个说明下： paginate:用来表示是否采用分页机制来获取数据，默认是True，采用分页。 marker:用来传递点击上一页或者下一页时，当前页面第一条或者最后一条project ID值。 sort_dir:用来指定数据库获取数据时排序，如果是点击下一页数据库获取数据排序是“acs”，上一页时“desc”排序 sort_key:用来指定排序字段，默认是project “id”值 openstack_dashboard/api/keystone.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344def tenant_list_paged(request, paginate=False, marker=None, domain=None, user=None, admin=True, filters=None, sort_key=&quot;name&quot;, sort_dir=&quot;desc&quot;, reversed_order=False): &quot;&quot;&quot; author: jpzhang.ht@gmail.com blog: http://www.smallartisan.site/ or http://blog.csdn.net/u011521019 &quot;&quot;&quot; has_more_data = False has_prev_data = False manager = VERSIONS.get_project_manager(request, admin=admin) limit = None page_size = utils.get_page_size(request) # 判断是否进行分页，如果分页从底层抓取数据的数据的时候夺取一条，用来判断是否还有更多的数据，用于判断是否显示下一页 if paginate: if reversed_order: sort_dir = &apos;desc&apos; if sort_dir == &apos;asc&apos; else &apos;asc&apos; limit = page_size + 1 # if requesting the projects for the current user, # return the list from the cache if user == request.user.id: tenants = request.user.authorized_tenants elif VERSIONS.active &lt; 3: # 判断keystone API 接口版本，这里使用的是2.0接口 tenants = manager.list_paged(limit, marker, sort_key=sort_key, sort_dir=sort_dir) # V3 API 这里主要通过V2API 来讲解，故此不对V3 API进行扩展 else: domain_id = get_effective_domain_id(request) kwargs = &#123; &quot;domain&quot;: domain_id, &quot;user&quot;: user &#125; if filters is not None: kwargs.update(filters) tenants = manager.list(**kwargs) tenants, has_more_data, has_prev_data = update_pagination( tenants, page_size, marker, sort_dir, sort_key, reversed_order) return (tenants, has_more_data, has_prev_data) 添加调用keystoneclient方法，其中： 1234if paginate: if reversed_order: sort_dir = &apos;desc&apos; if sort_dir == &apos;asc&apos; else &apos;asc&apos; limit = page_size + 1 根据paginate 和 reversed_order参数来确定获取数据时采用的排序方式。limit以及获取多少条数据。 manager.list_paged()自定义在keystoneclient的函数，用来发起request请求的函数。 update_pagination()函数，根据返回的数据长度设置has_more_data，has_prev_data属性值，如果是上一页数据，需要根据排序（“acs”／“desc”）反转排序处理，保证显示数据顺序正常，这种分页有一个弊端就是对每一个数据显示的顺序有依赖性，因为底层是用过传递过去ID来确定该条记录在数据库中的位置，以此来获取上一页或者下一页的数据。如果不怕麻烦可以通过django的Paginator分页模块，传递参数（当前页数、每页显示多少条记录）到底层进行分页，这种实现机制或更好一些，这里不再具体来说明，要实现页时比较简单。 12345678910111213141516171819202122def update_pagination(entities, page_size, marker, sort_dir, sort_key, reversed_order): has_more_data = has_prev_data = False if len(entities) &gt; page_size: has_more_data = True entities.pop() if marker is not None: has_prev_data = True # first page condition when reached via prev back elif reversed_order and marker is not None: has_more_data = True # last page condition elif marker is not None: has_prev_data = True # restore the original ordering here if reversed_order: entities = sorted(entities, key=lambda entity: (getattr(entity, &apos;id&apos;) or &apos;&apos;).lower(), reverse=(sort_dir == &apos;asc&apos;)) return entities, has_more_data, has_prev_data Keystoneclient:keystoneclient的修改比较简单，这里我们API接口用的是V2.0，因此我们只需要修改V2.0即可。keystoneclient/v2_0/tenants.py 123456789101112131415161718192021222324252627282930class TenantManager(base.ManagerWithFind):...... def list_paged(self, limit=None, marker=None, sort_key=None, sort_dir=None): &quot;&quot;&quot; author: jpzhang.ht@gmail.com blog: http://www.smallartisan.site/ or http://blog.csdn.net/u011521019 &quot;&quot;&quot; # 组拼参数 params = &#123;&#125; if limit: params[&apos;limit&apos;] = limit if marker: params[&apos;marker&apos;] = marker if sort_key: params[&apos;sort_key&apos;] = sort_key if sort_dir: params[&apos;sort_dir&apos;] = sort_dir query = &quot;&quot; if params: query = &quot;?&quot; + urllib.parse.urlencode(params) try: tenant_list = self._list(&apos;/tenants/paged%s&apos; % query, &apos;tenants&apos;) except exceptions.EndpointNotFound: endpoint_filter = &#123;&apos;interface&apos;: auth.AUTH_INTERFACE&#125; tenant_list = self._list(&apos;/tenants%s&apos; % query, &apos;tenants&apos;, endpoint_filter=endpoint_filter) return tenant_list keystoneclient 中在class TenantManager(base.ManagerWithFind)类中扩展def list_paged()函数，组拼GET请求发送的参数，以及GET请求发送的请求地址“/tenants/paged”，这个地址即为自己在keystone中自己扩展的API请求接口。 Keystone:keystone 处理tenants的逻辑代码主要放在/keystone/assignment中，本文不具体介绍keystone的目录结构以及代码逻辑，仅说明扩展接口完成tenants分页数据的展示。keystone/assignment/routers.py 12345678class Admin(wsgi.ComposableRouter): def add_routes(self, mapper): # add by jpzhang.ht@gmail.com 2016/08/20 mapper.connect(&apos;/tenants/paged&apos;, controller=tenant_controller, action=&apos;get_projects_for_token_paged&apos;, conditions=dict(method=[&apos;GET&apos;]))..... 定义请求路由映射，即请求地址为“/tenants/paged”，调用的控制器为“tenant_controller”，处理的函数为“get_projects_for_token_paged”，这里主要是请求路由与控制器处理函数建立映射关系。 在控制器中定义“get_projects_for_token_paged”处理函数:keystone/assignment/controllers.py 123456789101112131415161718192021class TenantAssignment(controller.V2Controller):@controller.v2_auth_deprecated def get_projects_for_token_paged(self, context, **kw): &quot;&quot;&quot; add by jpzhang.ht@gmail.com 2016/08/18 &quot;&quot;&quot; token_ref = utils.get_token_ref(context) params = &#123; &apos;limit&apos;: context[&apos;query_string&apos;].get(&apos;limit&apos;), &apos;marker&apos;: context[&apos;query_string&apos;].get(&apos;marker&apos;), &apos;sort_key&apos;: context[&apos;query_string&apos;].get(&apos;sort_key&apos;), &apos;sort_dir&apos;: context[&apos;query_string&apos;].get(&apos;sort_dir&apos;), &#125; tenant_refs = ( self.assignment_api.list_projects_for_user_paged(user_id=token_ref.user_id, params=params)) # tenant_refs = [self.v3_to_v2_project(ref) for ref in tenant_refs # if ref[&apos;domain_id&apos;] == CONF.identity.default_domain_id] return self.format_project_list(tenant_refs) 组拼GET过来的参数，self.assignment_api.list_projects_for_user_paged()函数过去tenants数据。 keystone/assignment/core.py 123456class Manager(manager.Manager): def list_projects_for_user_paged(self, user_id, params=None): &quot;&quot;&quot; add by jpzhang.ht@gmail.com 2016/08/20 &quot;&quot;&quot; return self.driver.list_projects_for_user_paged(user_id=user_id, params=params) 这里调用相应的driver获取数据，这里只针对sql进行扩展，对ldap、kvs不做扩展。 keystone/assignment/backends/sql.py 123456789101112131415161718192021222324class Assignment(keystone_assignment.AssignmentDriverV9):...... def list_projects_for_user_paged(self, role_id=None, user_id=None, group_ids=None, domain_id=None, project_ids=None, inherited_to_projects=None, params=None): &quot;&quot;&quot; add by jpzhang.ht@gmail.com 2016/08/18 &quot;&quot;&quot; with sql.session_for_read() as session: marker_row = None if params.has_key(&apos;marker&apos;): marker_row = session.query(Project).filter_by(id=params[&apos;marker&apos;]).first() query = session.query(Project) query = sqlalchemyutils.paginate_query(query, Project, params[&apos;limit&apos;], [params[&apos;sort_key&apos;]], marker=marker_row, sort_dir=params[&apos;sort_dir&apos;]) return query.all() 获取数据库中对应的记录，其中： 1marker_row = session.query(Project).filter_by(id=params[&apos;marker&apos;]).first() 根据传递过来的tenants id值获取这条记录在数据库中的位置，如果上一页倒序获取数据，原理简单推算下你就会明白为什么上页数据是倒序取。当然这里我写的比较暴力，之前考虑过沿用其目前的获取数据的方式，但发现最后因为上一页、下一页数据对传递过来的ID值依赖性比较强，并且“RoleAssignment”这张表tenants ID值并不是主键，将会导致根据marker值获取数据的记录将会不准，因此我这边直接去获取project这张表中的数据。重启keystone，apache即可查看分页已经实现：￼￼ 四、总结通过keystone tenant项目列表的分页，其实可以看出openstack的当前的分页现状，目前我这边方式实现分页比较暴力，如果想在其他组件上通过这种方式也是可行的例如镜像、配置模版等，不过需要经过测试是否可行，我这里就不在具体说明，如果大家有其他好的方式可以告知我，互相学习。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Python 数据结构和算法]]></title>
      <url>%2F2017%2F02%2F26%2F2017022604%2F</url>
      <content type="text"><![CDATA[一、写在前面这篇文章主要介绍了python 内置的数据结构（list、set以及字典），从一些实际的场景中来说明解决方案，主要是阅读《python cookbook》时写下的阅读记录，提高自己在Python开发方面的理解，记录在这里是为了方便可以随时查阅使用。因为时间仓促以及个人理解有限，固有错误的地方请指出，谢谢！ 如果转载，请保留作者信息。邮箱地址：jpzhang.ht@gmail.com个人博客：http://www.smallartisan.site/CSDN博客：http://blog.csdn.net/u011521019￼ 二、将序列分解为单独的变量任何序列（或可迭代的对象）都可以通过一个简单的赋值操作作为分解为单独的变量。唯一的要求是变量的总数和结构要与序列相吻合。 例如1： 12345678910111213141516&gt;&gt;&gt; p = (1, 2)&gt;&gt;&gt; x, y = p&gt;&gt;&gt; x1&gt;&gt;&gt; y2&gt;&gt;&gt; data = [&apos;jpzhang&apos;, 88, 99, (2016, 06, 15)]&gt;&gt;&gt; name, shares, price, date = data&gt;&gt;&gt; name&apos;jpzhang&apos;&gt;&gt;&gt; date(2016, 06, 15)&gt;&gt;&gt; name, shares, price, (year, mon, day) = data&gt;&gt;&gt; day15&gt;&gt;&gt; 如果元素的数量不匹配，将会得到一个错误的提示： 12345&gt;&gt;&gt; p = (1, 2)&gt;&gt;&gt; x, y, z = pTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: need more than 2 values to unpack 例如2：除了列表元祖，还包括字符串、文件、迭代器只要是可迭代对象 123456789&gt;&gt;&gt; str = &quot;Hello World&quot;&gt;&gt;&gt; a, b, c, d, e, f, g, h, i, j, k = str&gt;&gt;&gt; a&apos;H&apos;&gt;&gt;&gt; b&apos;e&apos;&gt;&gt;&gt; g&apos;W&apos;&gt;&gt;&gt; 例如3：去除特定列表中的值,把不需要的值存放到不会用到的变量上， 123456&gt;&gt;&gt; data = [&apos;jpzhang&apos;, 88, 99, (2016, 06, 15)]&gt;&gt;&gt; _, shares, price, _ = data&gt;&gt;&gt; _(2016, 6, 15)&gt;&gt;&gt; shares88 三、从任意长度的可迭代对象中分解元素从一个可迭代对象中分解出N个元素，可迭代对象的长度可能超过N，实现方式，通过Python的“＊表达式”，例如：需要python3支持，python2.7不支持 123456789101112131415161718#!/usr/bin/python# -*- coding:utf-8 -*- __author__ = &apos;jpzhang&apos;import numpydef avg(l): return float(sum(l))/max(len(l),1)def drop_first_last(grades): # first, *middle, last = grades --- python3.0 middle = grades[1:-1] # --- python2.7 return numpy.mean(middle) # or def avg()if __name__ == &apos;__main__&apos;: grades = [1, 2, 3, 4, 5] grades_avg = drop_first_last(grades) print grades_avg 四、保留最后N个元素在迭代或者是其他形式的处理过程中对最后几项记录做一个有限的历史纪录统计。例如：下面的代码对一系列文本行做简单的文本匹配操作，当发现有匹配（python）字符数时就输出当前的匹配行，以及最近前面检查过的N行文本。 1234567891011121314151617181920212223#!/usr/bin/python# -*- coding:utf-8 -*- __author__ = &apos;jpzhang&apos;__sites__ = &apos;http://www.smallartisan.site/&apos;from collections import dequedef search(lines, pattern, history=5): previons_line = deque(maxlen=history) for line in lines: if pattern in line: yield line, previons_line previons_line.append(line)# Example use on a fileif __name__ == &apos;__main__&apos;: with open(&apos;./somefile.txt&apos;) as f: for line, prevlines in search(f, &apos;python&apos;, 5): for pline in prevlines: print(pline, &quot;end=&apos;&apos;&quot;) print(line, &quot;end=&apos;&apos;&quot;) print(&apos;-&apos;*20) yield 的作用就是把一个函数变成一个 generator，带有 yield 的函数不再是一个普通函数，Python 解释器会将其视为一个 generator，调用 search() 不会执行 search() 函数，而是返回一个 iterable 对象！在 for 循环执行时，每次循环都会执行 search() 函数内部的代码，执行到 yield line, previons_line 时，fab 函数就返回一个迭代值，下次迭代时，代码从 yield line, previons_line 的下一条语句继续执行，而函数的本地变量看起来和上次中断执行前是完全一样的，于是函数继续执行，直到再次遇到 yield。 如同上面的代码片段所做的一样，当编写搜索某项纪录的代码时，通常会用到含有yield关键字的生成器迭代函数。这将处理搜索过程的代码和使用搜索结果的代码成功解耦开来。 deque(maxlen=N) 创建了一个固定长度的队列，当有新的记录加入而队列已满时会自动移动除最老的那条记录。例如： 12345678910111213&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; q = deque(maxlen=3)&gt;&gt;&gt; q.append(1)&gt;&gt;&gt; q.append(2)&gt;&gt;&gt; q.append(3)&gt;&gt;&gt; qdeque([1, 2, 3], maxlen=3)&gt;&gt;&gt; q.append(4)&gt;&gt;&gt; qdeque([2, 3, 4], maxlen=3)&gt;&gt;&gt; q.append(5)&gt;&gt;&gt; qdeque([3, 4, 5], maxlen=3) 虽然通过列表操作（append、del）也能够完成deque的功能，但是队列的这种解决方案要更优雅的多，运行速度也将更快。如果deque不指定队列长度，将得到一个无界限的队列，可以在两端执行添加和弹出操作，例如： 12345678910111213141516&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; q = deque()&gt;&gt;&gt; q.append(1)&gt;&gt;&gt; q.append(2)&gt;&gt;&gt; q.append(3)&gt;&gt;&gt; qdeque([1, 2, 3])&gt;&gt;&gt; q.appendleft(4)&gt;&gt;&gt; qdeque([4, 1, 2, 3])&gt;&gt;&gt; q.pop()3&gt;&gt;&gt; qdeque([4, 1, 2])&gt;&gt;&gt; q.popleft()4 从队列两端添加或者弹出元素的复杂度都是O(1)。这和列表不同，当从列表的头部插入或者移除元素时，列表的复杂度为O(N) 五、找到最大或者最小的N个元素在集合中查找最大或最小的N个元素。 heapq 模块中有两个函数——nlargest()和nsmallest()——他们正是我们所需要的。例如： 123456&gt;&gt;&gt; import heapq&gt;&gt;&gt; nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]&gt;&gt;&gt; print(heapq.nlargest(3, nums))[42, 37, 23]&gt;&gt;&gt; print(heapq.nsmallest(3, nums))[-4, 1, 2] 这两个函数都可以接受一个参数key，从而允许他们可以工作在更加复杂的数据结构之上。例如： 1234567891011&gt;&gt;&gt; import heapq&gt;&gt;&gt; phone = [&#123;&apos;name&apos;: &apos;sanxing&apos;, &apos;shares&apos;: 100, &apos;price&apos;: 100.11&#125;,... &#123;&apos;name&apos;: &apos;huawei&apos;, &apos;shares&apos;: 89, &apos;price&apos;: 99.31&#125;,... &#123;&apos;name&apos;: &apos;xiaomi&apos;, &apos;shares&apos;: 22, &apos;price&apos;: 89.11&#125;,... &#123;&apos;name&apos;: &apos;iphone&apos;, &apos;shares&apos;: 55, &apos;price&apos;: 34.11&#125;]&gt;&gt;&gt; cheap = heapq.nsmallest(3, phone, key=lambda s: s[&apos;price&apos;])&gt;&gt;&gt; cheap[&#123;&apos;price&apos;: 34.11, &apos;name&apos;: &apos;iphone&apos;, &apos;shares&apos;: 55&#125;, &#123;&apos;price&apos;: 89.11, &apos;name&apos;: &apos;xiaomi&apos;, &apos;shares&apos;: 22&#125;, &#123;&apos;price&apos;: 99.31, &apos;name&apos;: &apos;huawei&apos;, &apos;shares&apos;: 89&#125;]&gt;&gt;&gt; expensive = heapq.nlargest(3, phone, key=lambda s: s[&apos;price&apos;])&gt;&gt;&gt; expensive[&#123;&apos;price&apos;: 100.11, &apos;name&apos;: &apos;sanxing&apos;, &apos;shares&apos;: 100&#125;, &#123;&apos;price&apos;: 99.31, &apos;name&apos;: &apos;huawei&apos;, &apos;shares&apos;: 89&#125;, &#123;&apos;price&apos;: 89.11, &apos;name&apos;: &apos;xiaomi&apos;, &apos;shares&apos;: 22&#125;] 如果正在寻找最大或者最小的N个元素，且同集合中元素的总数目相比，N很小，那么下面的这些函数可以提供更好的性能。首先这些函数会在底层将数据转化成列表，且元素以堆的顺序排列。例如： 1234567891011121314&gt;&gt;&gt; nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 37, 2]&gt;&gt;&gt; import heapq&gt;&gt;&gt; heap = list(nums)&gt;&gt;&gt; heapq.heapify(heap)&gt;&gt;&gt; heap[-4, 7, 1, 23, 8, 2, 18, 23, 42, 37, 37, 2]&gt;&gt;&gt; heapq.heappop(heap)-4&gt;&gt;&gt; heap[1, 7, 2, 23, 8, 2, 18, 23, 42, 37, 37]&gt;&gt;&gt; heapq.heappop(heap)1&gt;&gt;&gt; heapq.heappop(heap)2 当所要找的元素数量相对较小时，函数nlargest()和nsmallest()才是最合适的，如果只是简单的想找出最小或最大的元素（N＝1时），那么用min()和max()会更快。如果N和集合本身的大小差不多大，通常更快的方法是先对集合排序，然后最切片操作（例如，使用sorted(items)[:N]或者sorted(items[-N:])。 六、实现优先级队列实现一个队列，能够以给定的优先级来对元素排序，且每次pop操作时都会返回优先级最高的那个元素。 heapq模块实现了python中的堆排序，并提供了有关的方法。让用python实现排序算法有了简单的快捷的方式。 heappush():heapq.heappush(heap, item),将item压入到堆书组中heap中。如果不进行此步操作，后面的heappop失效。 heappop():heapq.heappop(heap),从堆数组heap中取出最小的值，并返回。 例如： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!/usr/bin/python# -*- coding:utf-8 -*- __author__ = &apos;jpzhang&apos;__sites__ = &apos;http://www.smallartisan.site/&apos;import heapqclass PriorityQueue: def __init__(self): self._queue = [] self._index = 0 def push(self, item, priority): heapq.heappush(self._queue, (-priority, self._index, item)) self._index += 1 def pop(self): return heapq.heappop(self._queue)[-1]class Item: def __init__(self, name): self.name = name def __repr__(self): return (&apos;Item %s&apos;, self.name)if __name__ == &apos;__main__&apos;: q = PriorityQueue() q.push(Item(&apos;foo&apos;), 1) q.push(Item(&apos;bar&apos;), 5) q.push(Item(&apos;spam&apos;), 4) q.push(Item(&apos;grok&apos;), 1) print q.pop().name print(&apos;---------------------&apos;) print q.pop().name print(&apos;---------------------&apos;) print q.pop().name print(&apos;---------------------&apos;) print q.pop().name 控制台输出：bar---------------------spam---------------------foo---------------------grok 第一次执行pop() 操作时返回的元素具有最高的优先级,拥有相同优先级的两个元素（foo, grok）返回顺序同他们插入到队列的顺序相同。 函数heapq.heappush()以及heapq.heappop()分别实现将元素从列表_queue中插入和移除，且保证列表中第一个元素的优先级最低。heappop()方法重视返回“最小”的元素，因此这就是让队列能够弹出真确元素的关键。此外，由于push和pop操作的复杂度都是O(logN),其中N代表堆中元素的数量，因此就算N的值很大，这些操作的效率也非常高。代码中，队列以元组（-priority, index, item）的形式组成。把priority取负指是为了让队列能够按照元素的优先级从高到低的顺序排列。这和正常的堆顺序是相反的，一般情况下堆是按从小到大的顺序排序的。变量index的作用是为了将具有相同优先级的元素以适当的顺序排列。通过维护一个不断递增的索引，元素将以他们入队列时的顺序来排列。但是，index在对具有相同优先级的元素间做比较操作时同样扮演了重要的角色。更多关于heapq的介绍请参考官方 七、在字典中将多个健映射到多个值上将健（key）映射到多个值的字典（即所谓的一键多值字典［multidict］）字典是一种关联容器，每个健都映射到一个单独的值上。如果想让健映射到 多个值，需要将这多个值保存到另一个容器列表或集合中。例如： 123456789d = &#123; &apos;a&apos;: [1, 2, 3], &apos;b&apos;: [4, 5]&#125;e = &#123; &apos;a&apos;: &#123;1, 2, 3&#125; &apos;b&apos;: &#123;4, 5&#125;&#125; 如果需要保留元素插入的顺序，就用列表，如果需要消除重复元素（且不在意他们的顺序），就用集合。 快速方便创建这样的字典，可以利用collections模块中的defaultdict类。 defaultdict的一个特点就是它会自动初始化第一个值，这样只需要关注添加的元素即可。例如： 123456789101112131415161718192021222324252627#!/usr/bin/python# -*- coding:utf-8 -*- __author__ = &apos;jpzhang&apos;__sites__ = &apos;http://www.smallartisan.site/&apos;from collections import defaultdictd = defaultdict(list)d[&apos;a&apos;].append(1)d[&apos;a&apos;].append(2)d[&apos;b&apos;].append(4)print(d)print(&apos;================================&apos;)b = defaultdict(set)b[&apos;a&apos;].add(1)b[&apos;a&apos;].add(2)b[&apos;b&apos;].add(4)print(b)控制台输出：defaultdict(&lt;type &apos;list&apos;&gt;, &#123;&apos;a&apos;: [1, 2], &apos;b&apos;: [4]&#125;)================================defaultdict(&lt;type &apos;set&apos;&gt;, &#123;&apos;a&apos;: set([1, 2]), &apos;b&apos;: set([4])&#125;) 关于defaultdict,需要注意的一个地方是，他会自动创建字典表项以待稍后的访问（即使这些表项当前在字典中还没有找到）。如果不想要这个功能，可以在普通的字典上调用setdefault方法来取代。例如： 123456789c = &#123;&#125;c.setdefault(&apos;a&apos;, []).append(1)c.setdefault(&apos;a&apos;, []).append(2)c.setdefault(&apos;b&apos;, []).append(3)print(c[&apos;a&apos;])输出：[1, 2] 构建一个一键多值字典是很容易的。但是如果试着自己对第一个值做初始化操作，这就会变的很杂论。例如： 1234567891011121314151617#!/usr/bin/python# -*- coding:utf-8 -*- __author__ = &apos;jpzhang&apos;__sites__ = &apos;http://www.smallartisan.site/&apos;from collections import defaultdictd = &#123;&#125;for key, value in pairs: if key not in d: d[key] = [] d[key].append(value)# 使用defaultdict后代码会清晰的多：d = defaultdict(list)for key, value in pairs: d[key].append(value) 八、让字典保持有序创建一个字典，并且在迭代或序列化这个字典的时候能够控制元素的顺序。控制一个字典中元素的顺序，你可以使用 collections 模块中的 OrderedDict 类。 在迭代操作的时候它会保持元素被插入时的顺序，示例如下： 1234567891011121314151617181920212223242526#!/usr/bin/python# -*- coding:utf-8 -*- __author__ = &apos;jpzhang&apos;__sites__ = &apos;http://www.smallartisan.site/&apos;from collections import OrderedDictdef ordered_dict(): d = OrderedDict() d[&apos;foo&apos;] = 1 d[&apos;bar&apos;] = 2 d[&apos;spam&apos;] = 3 d[&apos;grok&apos;] = 4 # Outputs &quot;foo 1&quot;, &quot;bar 2&quot;, &quot;spam 3&quot;, &quot;grok 4&quot; for key in d: print(key, d[key])if __name__ == &apos;__main__&apos;: ordered_dict() 控制输出：(&apos;foo&apos;, 1)(&apos;bar&apos;, 2)(&apos;spam&apos;, 3)(&apos;grok&apos;, 4) 当你构建一个映射结构以便稍后对其做序列化编码成另一种格式时，OrderedDict就显示的特别有用。例如，如果在想进行JSON编码时精确控制各字段的顺序，那么只要首先OrderedDict中构建数据就可以了。 1234&gt;&gt;&gt; import json&gt;&gt;&gt; json.dumps(d)&apos;&#123;&quot;foo&quot;: 1, &quot;bar&quot;: 2, &quot;spam&quot;: 3, &quot;grok&quot;: 4&#125;&apos;&gt;&gt;&gt; 有可能在你本地调试的时候会报错： 1234Traceback (most recent call last): File &quot;/Users/jpzhang/Documents/开发/Python/demo/python cookbook/demo06.py&quot;, line 6, in &lt;module&gt; from collections import OrderedDictImportError: cannot import name OrderedDict 网上查阅了下： 123456789101112131415161718http://stackoverflow.com/questions/14358162/funnelweb-error-cannot-import-ordereddictOrderedDict is a new class added to Python 2.7, so it is missing in your case.You can install a backport:pip install ordereddictor add that as a dependency in your buildout, and edit Plone/buildout-cache/eggs/transmogrify.webcrawler-1.2.1-py2.6.egg/transmogrify/webcrawler/webcrawler.py line 21 to change the import from:from collections import OrderedDicttotry: from collections import OrderedDictexcept ImportError: # python 2.6 or earlier, use backport from ordereddict import OrderedDictI have filed an issue in the funnelweb issue tracker to request that this is added to a future release of the package, see issue 22. OrderedDict 内部维护着一个根据键插入顺序排序的双向链表。每次当一个新的元素插入进来的时候， 它会被放到链表的尾部。对于一个已经存在的键的重复赋值不会改变键的顺序。 需要注意的是，一个 OrderedDict 的大小是一个普通字典的两倍，因为它内部维护着另外一个链表。 所以如果你要构建一个需要大量 OrderedDict 实例的数据结构的时候(比如读取100,000行CSV数据到一个 OrderedDict 列表中去)， 那么你就得仔细权衡一下是否使用 OrderedDict 带来的好处要大过额外内存消耗的影响。 九、字典的计算在字典上对数据执行各式各样的计算（比如求最小值、最大值、排序等等）例如：假设有一个字典在股票名称和价格间做了映射：为了对字典值执行有用的计算操作，通常需要使用 zip() 函数先将键和值反转过来。 比如，下面是查找最小和最大股票价格和股票值的代码： 12345min_price = min(zip(prices.values(), prices.keys()))# min_price is (10.75, &apos;FB&apos;)max_price = max(zip(prices.values(), prices.keys()))# max_price is (612.78, &apos;AAPL&apos;) 同样，要对数据排序只要使用zip() 再配合sorted()就可以了，比如： 1234prices_sorted = sorted(zip(prices.values(), prices.keys()))# prices_sorted is [(10.75, &apos;FB&apos;), (37.2, &apos;HPQ&apos;),# (45.23, &apos;ACME&apos;), (205.55, &apos;IBM&apos;),# (612.78, &apos;AAPL&apos;)] 当进行这些计算时，请注意zip() 创建了一个迭代器，它的内容只能被消费一次。例如下面的代码就是错误的： 123prices_and_names = zip(prices.values(), prices.keys())print(min(prices_and_names)) # OKprint(max(prices_and_names)) # ValueError: max() arg is an empty sequence 完整示例代码： 123456789101112131415161718192021222324252627282930313233343536373839#!/usr/bin/python# -*- coding:utf-8 -*- __author__ = &apos;jpzhang&apos;__sites__ = &apos;http://www.smallartisan.site/&apos;prices = &#123; &apos;ACME&apos;: 45.23, &apos;AAPL&apos;: 612.78, &apos;IBM&apos;: 205.55, &apos;HPQ&apos;: 37.20, &apos;FB&apos;: 10.75&#125;min_price = min(zip(prices.values(), prices.keys()))# min_price is (10.75, &apos;FB&apos;)max_price = max(zip(prices.values(), prices.keys()))# max_price is (612.78, &apos;AAPL&apos;)print(min_price)print(&apos;-----------------------------&apos;)print(max_price)print(&apos;------------sorted-----------------&apos;)prices_sorted = sorted(zip(prices.values(), prices.keys()))# prices_sorted is [(10.75, &apos;FB&apos;), (37.2, &apos;HPQ&apos;),# (45.23, &apos;ACME&apos;), (205.55, &apos;IBM&apos;),# (612.78, &apos;AAPL&apos;)]print(prices_sorted)控制台输出：(10.75, &apos;FB&apos;)-----------------------------(612.77999999999997, &apos;AAPL&apos;)------------sorted-----------------[(10.75, &apos;FB&apos;), (37.200000000000003, &apos;HPQ&apos;), (45.229999999999997, &apos;ACME&apos;), (205.55000000000001, &apos;IBM&apos;), (612.77999999999997, &apos;AAPL&apos;)] 如果你在一个字典上执行普通的数学运算，你会发现它们仅仅作用于键，而不是值。比如： 12min(prices) # Returns &apos;AAPL&apos;max(prices) # Returns &apos;IBM&apos; 这个结果并不是你想要的，因为你想要在字典的值集合上执行这些计算。 或许你会尝试着使用字典的 values() 方法来解决这个问题： 12min(prices.values()) # Returns 10.75max(prices.values()) # Returns 612.78 不幸的是，通常这个结果同样也不是你想要的。 你可能还想要知道对应的键的信息(比如那种股票价格是最低的？)。 你可以在 min() 和 max() 函数中提供 key 函数参数来获取最小值或最大值对应的键的信息。比如： 12min(prices, key=lambda k: prices[k]) # Returns &apos;FB&apos;max(prices, key=lambda k: prices[k]) # Returns &apos;AAPL&apos; 但是，如果还想要得到最小值，你又得执行一次查找操作。比如： 1min_value = prices[min(prices, key=lambda k: prices[k])] 前面的 zip() 函数方案通过将字典”反转”为(值，键)元组序列来解决了上述问题。 当比较两个元组的时候，值会先进行比较，然后才是键。 这样的话你就能通过一条简单的语句就能很轻松的实现在字典上的求最值和排序操作了。 需要注意的是在计算操作中使用到了(值，键)对。当多个实体拥有相同的值的时候，键会决定返回结果。 比如，在执行 min() 和 max() 操作的时候，如果恰巧最小或最大值有重复的，那么拥有最小或最大键的实体会返回：例如： 123456&gt;&gt;&gt; prices = &#123; &apos;AAA&apos; : 45.23, &apos;ZZZ&apos;: 45.23 &#125;&gt;&gt;&gt; min(zip(prices.values(), prices.keys()))(45.23, &apos;AAA&apos;)&gt;&gt;&gt; max(zip(prices.values(), prices.keys()))(45.23, &apos;ZZZ&apos;)&gt;&gt;&gt; 十、查找两字典的相同点有两个字典，我们想找出它们中间可能的相同的地方（相同的健、相同的值等）。 考虑两个字典： 1234567891011a = &#123; &apos;x&apos; : 1, &apos;y&apos; : 2, &apos;z&apos; : 3&#125;b = &#123; &apos;w&apos; : 10, &apos;x&apos; : 11, &apos;y&apos; : 2&#125; 要找出这两个字典中的相同之处，只需要通过keys()或者items()方法执行常见的集合操作即可。例如： 123456# Find keys in commona.keys() &amp; b.keys() # &#123; &apos;x&apos;, &apos;y&apos; &#125;# Find keys in a that are not in ba.keys() - b.keys() # &#123; &apos;z&apos; &#125;# Find (key,value) pairs in commona.items() &amp; b.items() # &#123; (&apos;y&apos;, 2) &#125; 这些类型的操作也可以用来修改或过滤掉字典中的内容，例如，假设想创建一个新的字典，其中会去掉某些健。下面是使用了字典推导式的代码示例： 123# Make a new dictionary with certain keys removedc = &#123;key:a[key] for key in a.keys() - &#123;&apos;z&apos;, &apos;w&apos;&#125;&#125;# c is &#123;&apos;x&apos;: 1, &apos;y&apos;: 2&#125; 一个字典就是一个键集合与值集合的映射关系。 字典的 keys() 方法返回一个展现键集合的键视图对象。 键视图的一个很少被了解的特性就是它们也支持集合操作，比如集合并、交、差运算。 所以，如果你想对集合的键执行一些普通的集合操作，可以直接使用键视图对象而不用先将它们转换成一个set。 字典的 items() 方法返回一个包含(键，值)对的元素视图对象。 这个对象同样也支持集合操作，并且可以被用来查找两个字典有哪些相同的键值对。 尽管字典的 values() 方法也是类似，但是它并不支持这里介绍的集合操作。 某种程度上是因为值视图不能保证所有的值互不相同，这样会导致某些集合操作会出现问题。 不过，如果你硬要在值上面执行这些集合操作的话，你可以先将值集合转换成set，然后再执行集合运算就行了。 十一、从序列中移除重复项且保持元素间顺序不变我们想去除序列中出现的重复元素，但依旧保持剩下的元素顺序不变 如果序列上的值都是可哈希（hashable）的，那么可以很简单的利用集合或者生成器来解决这个问题。比如： 12345678910111213141516#!/usr/bin/python# -*- coding:utf-8 -*- __author__ = &apos;jpzhang&apos;__sites__ = &apos;http://www.smallartisan.site/&apos;def dedupe(items): seen = set() for item in items: if item not in seen: yield item seen.add(item)if __name__ == &apos;__main__&apos;: a = [1, 5, 2, 1, 9, 1, 5, 10] b = list(dedupe(a)) print(b) 这个方法仅仅在序列中元素为 hashable 的时候才管用。 如果你想消除元素不可哈希(比如 dict 类型)的序列中重复元素的话，你需要将上述代码稍微改变一下，就像这样： 1234567891011121314151617#!/usr/bin/python# -*- coding:utf-8 -*- __author__ = &apos;jpzhang&apos;__sites__ = &apos;http://www.smallartisan.site/&apos;def dedupe(items, key=None): seen = set() for item in items: val = item if key is None else key(item) if val not in seen: yield item seen.add(val)if __name__ == &apos;__main__&apos;: a = [ &#123;&apos;x&apos;:1, &apos;y&apos;:2&#125;, &#123;&apos;x&apos;:1, &apos;y&apos;:3&#125;, &#123;&apos;x&apos;:1, &apos;y&apos;:2&#125;, &#123;&apos;x&apos;:2, &apos;y&apos;:4&#125;] print(list(dedupe(a, key=lambda d: (d[&apos;x&apos;],d[&apos;y&apos;])))) print(list(dedupe(a, key=lambda d: d[&apos;x&apos;]))) 这里的key参数指定了一个函数，将序列元素转换成 hashable 类型。如果你想基于单个字段、属性或者某个更大的数据结构来消除重复元素，第二种方案同样可以胜任。 如果你仅仅就是想消除重复元素，通常可以简单的构造一个集合。比如： 123456&gt;&gt;&gt; a = [1, 5, 2, 1, 9, 1, 5, 10]&gt;&gt;&gt; a[1, 5, 2, 1, 9, 1, 5, 10]&gt;&gt;&gt; set(a)set([1, 2, 10, 5, 9])&gt;&gt;&gt; 但是这种方式不能保证元素间的顺序不变，因此得到的结果会被打乱。前面展示的解决方案可避免出现这个问题。 对生成器的使用反映一个事实，那就是我们可能会希望这个函数尽可能的通用——不必绑定在只能对列表进行处理。比如，如果想读一个文件，去除其中重复的文本行，可以只需要这样处理： 123with open(somefile,&apos;r&apos;) as f:for line in dedupe(f): ... dedupe()函数模仿了内置函数 sorted() , min() 和 max()对key函数的使用方式 总结《python cookbook》 这本写的内容比较有实战意义，很多处理方式是我们在日常开发中会比较多的涉及，建议大家没事的时候多翻翻。在这篇文章发布之初的目的是为了记录下来方便以后自己查询，后来查到，网上已经有牛人将它翻译整理成好了，后续不会更新相关的文章，更多的信息可以在线查阅]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OpenStack Mitaka Horiozn 主题开发]]></title>
      <url>%2F2017%2F02%2F26%2F2017022603%2F</url>
      <content type="text"><![CDATA[OpenStack Mitaka Horiozn 主题开发一、写在前面这篇文章主要介绍了OpenStack Mitaka Horizo主题包的开发。这里只是说明horiozn主题包的开发逻辑，不具体阐述css、js、html文件的开发， 仅仅是说明horizon主题开发的方式，因为时间仓促以及个人理解有限，固有错误的地方请指出，后续将会不定期的完善，谢谢！如果转载，请保留作者信息。邮箱地址：jpzhang.ht@gmail.com主题下载地址：http://www.smallartisan.site/?p=38￼ 二、环境准备注意：如果没有特殊说明，一下所有命令均是在root用户下执行。 通过devstack 部署OpenStack Mitaka单节点基础版本（nova、keystone、glance、vloume、horizon），具体如何部署可以参考我的另一片博文，部署完成之后可以看到目录结构如下：.├── cinder├── glance├── horizon├── keystone├── logs├── neutron├── nova├── noVNC├── requirements└── tempest可以看到我这里安装的所有组件的源码包，根据实际情况会有不同，以自己的的为主。这里主要介绍horizon组件theme的开发，其他组件这里不涉及，不需要关注，只要保证各个服务时运行正常即OK，后续将逐渐来说明其他的组件的开发，大家可以关注下我的博客或者最近刚建的博客，后续将同步更新,废话不多说，进入正题。拷贝一份horizon代码包： 1cp -r horizon horizon.dev 进入：cd horizon.dev通过django 自带的测试服务，运行horizon组件 12345678910python manage.py runserver 0.0.0.0:8001输出：Performing system checks...System check identified no issues (0 silenced).June 12, 2016 - 13:21:59Django version 1.8.10, using settings &apos;openstack_dashboard.settings&apos;Starting development server at http://0.0.0.0:8001/Quit the server with CONTROL-C. 如果是通过devstack部署的，通过这种方式运行起来的horizon，通过浏览器访问,浏览器将会出现如下错误： 1234567891011121314151617181920212223Page not found (404)Request Method: GETRequest URL: http://192.168.31.235:8001/dashboard/auth/login/?next=/Using the URLconf defined in openstack_dashboard.urls, Django tried these URL patterns, in this order:^$ [name=&apos;splash&apos;]^api/^home/$ [name=&apos;user_home&apos;]^i18n/js/(?P&lt;packages&gt;\S+?)/$ [name=&apos;jsi18n&apos;]^i18n/setlang/$ [name=&apos;set_language&apos;]^i18n/^jasmine-legacy/$ [name=&apos;jasmine_tests&apos;]^jasmine/.*?$^identity/^developer/^admin/^settings/^project/^auth/^dashboard\/static\/(?P&lt;path&gt;.*)$^dashboard\/media\/(?P&lt;path&gt;.*)$^500/$The current URL, dashboard/auth/login/, didn&apos;t match any of these.You&apos;re seeing this error because you have DEBUG = True in your Django settings file. Change that to False, and Django will display a standard 404 page. 你可以看到浏览器url地址栏默认跳转到了：“http://192.168.31.235:8001/dashboard/auth/login/?next=/“如果我们手动把浏览器地址栏中的/dashoboard/去除再次刷新就可以看到熟悉的horizon默认的登录界面 不用担心，这是因为horizon的配置文件配置的url里面默认根目录是从“dashboard”开始的，如果通过apache运行，就可以在apache horizon的配置中看到，默认horiozn的资源访问路径是从‘dashboard’开始，apache如下： 12345678910111213WSGIScriptAlias /dashboard /home/devstack.mitaka/horizon/openstack_dashboard/wsgi/django.wsgi WSGIDaemonProcess horizon user=stack group=stack processes=3 threads=10 home=/home/devstack.mitaka/horizon display-name=%&#123;GROUP&#125; WSGIApplicationGroup %&#123;GLOBAL&#125; SetEnv APACHE_RUN_USER stack SetEnv APACHE_RUN_GROUP stack WSGIProcessGroup horizon DocumentRoot /home/devstack.mitaka/horizon/.blackhole/ Alias /dashboard/media /home/devstack.mitaka/horizon/openstack_dashboard/static Alias /dashboard/static /home/devstack.mitaka/horizon/static RedirectMatch &quot;^/$&quot; &quot;/dashboard/&quot; 那这里我们只要修改horizon的配置，让其默认的访问路径从“/”开始即可正常。具体修改： 1234567891011121314vi horizon.dev/openstack_dashboard/local/local_settings.py找到：WEBROOT=&quot;/dashboard/&quot;修改为：WEBROOT=&quot;/&quot;cd horizon.dev/运行（静态文件压缩）：python manage.py compress输出：Found &apos;compress&apos; tags in: /home/devstack.mitaka/horizon.dev/openstack_dashboard/templates/horizon/_conf.html /home/devstack.mitaka/horizon.dev/openstack_dashboard/templates/_stylesheets.html /home/devstack.mitaka/horizon.dev/openstack_dashboard/templates/horizon/_scripts.htmlCompressing... doneCompressed 5 block(s) from 3 template(s) for 2 context(s). 重启服务：python manage.py runserver 0.0.0.0:8001再次访问浏览器地址：http://192.168.31.235:8001/这回自动跳转到：http://192.168.31.235:8001/auth/login/?next=/地址栏中没有出现“/dashboard/” 并且正常出现horizon登录界面，至此我们的开发环境准备完成，至于用什么IDE来开发，我相信每个程序员都有自己的喜好，这里我使用Sublime来开发，个人比较偏向于pycharm来开发，无奈环境安装在虚拟机中，pycharm社区版不支持远程开发，正好sublime有sftp工具能够远程通过代码进行开发，一拍即合，这里就用sublime来进行开发工作。 三、目录结构Horizon目录结构介绍，之前有一篇博文进行了专门的介绍，不了解的可以翻一翻，这里主要介绍下几个主题开发会用到的目录以及自己创建的主题包:.├── doc├── horizon├── horizon.egg-info├── openstack_dashboard├── releasenotes├── static└── tools可以看到horizon最外层有一个static静态文件目录,这个静态目录是用来干什么的呢？进入目录可以看到它的结构如下：.├── app├── auth├── bootstrap├── dashboard├── framework├── horizon├── scss└── themes 这个目录其实就是horizon界面访问的静态文件的统一入口，所有样式模版（css、js、html）都是这个目录提供的，那是不是我们开发的静态文件放在这个目录中呢，其实不然，我这个目录的文件是通过一个命名生成的，命令：python manage.py collectstatic一般我会在后面加一个 “-c” 的参数，把原先 static目录中的内容清空。大家可以通过python manage.py collectstatic －h 具体查看这个命令的功能，简单来说会把horizon目录下以及dashboard目录下所有用到的静态文件统一拷贝到这个目录中，在通过命令进行压缩，为上层提供所有的样式文件。命令：python manage.py compress horizon.dev/horizon目录，这个目录用来定义horizon组件全局的样式文件，其中包括一个static、 templates、templatetags 目录，static：存放一些静态文件CSS、 JStemplates：存放模版文件主要是html页面templatetags：定义html模版页面中出现出现的标签例如：在horizon.dev/horizon/templates/horizon/_nav_list.html { % if user|has_permissions:component % }，horizon.dev/horizon/templatetags/horizon.py中就有定义。 horizon.dev/openstack_dashboard目录，同样在这个目录下也包括static、 templates、templatetags 目录，作用和上述的一样，不过这里定义的不是全局的，可以把它当作是对horizon目录中定义的文件，在这里在做差距化的定义。 那么horion加载的同一个文件在两个地方都有的情况下回调用哪个文件，这个你可以看下django 模版调用机制，horiozn组件很好的利用了这一点，这里我也记不太清了，记忆中是先调用openstck目录中的，找不到的情况下会去horizon里面去找。好了，具体不再细聊了，接下去就开始我们定制化的开发工作。 四、bruce主题初始化进入我们的主题开发目录，通过拷贝现有的material目录结构来具体说明： 1cd horizon.dev/openstack_dashboard/themes 该目录用来存放horizon组件的所有的主题包，默认已经有两个目录包default、material 在上个版本中，已经支持主题开发，甚至在juno版本中也支持了，只是在Mitaka更加完善了这部分，如果学会了在Mitaka版本的开发原理，在juno版本中开发也是如此。默认horizon采用的是default 目录，但是可以通过dashboard界面的切换主题的按钮进行主题切换如下：￼ 拷贝一份“Material”目录为bruce目录 1cp -r material/ bruce 如果仅仅拷贝一份还是不行的，要让horizon识别，还需要在配置文件中进行配置，这里我为了方便直接修改了settings.py(你也可以修改local/local_settings.py)： 1vi horizon.dev/openstack_dashboard/settings.py 12345678910111213141516AVAILABLE_THEMES = [ ( &apos;default&apos;, pgettext_lazy(&apos;Default style theme&apos;, &apos;Default&apos;), &apos;themes/default&apos; ), ( &apos;material&apos;, pgettext_lazy(&quot;Google&apos;s Material Design style theme&quot;, &quot;Material&quot;), &apos;themes/material&apos; ), ( &apos;bruce&apos;, pgettext_lazy(&quot;Google&apos;s Material Design style theme&quot;, &quot;Bruce&quot;), &apos;themes/bruce&apos; ),] 这个时候你刷新浏览器会提示错误，需要你运行“python manage.py compress”，重新编译压缩下，那就按照提示做，运行命令： 12python manage.py compress重启： python manage.py runserver 0.0.0.0:8001 再次刷新浏览器，你就可以看到刚刚我们定义的主题bruce：￼ 切换至Bruce主题可以看到和Material一样的样式主题 Bruce从Material拷贝过来当然一样。那么如何让我们的Bruce主题成为horizon主题默认主题呢，还是一样，修改 1vi horizon.dev/openstack_dashboard/settings.py 1DEFAULT_THEME = &apos;default&apos; =&gt; DEFAULT_THEME = &apos;bruce&apos; 这个时候你清空浏览器缓存，重新登录horiozn，你就会发现horizon默认的主题采用的不是“default”而是我们定义的“bruce”。 接下来我们来具体认识下从Material拷贝过来的目录包括了哪些东西，具体有什么用。.├── static│ ├── bootstrap│ ├── horizon│ └── js│ └── _styles.scss│ └── _variables.scss│└── templates ├── auth ├── header ├── horizon └── material static（静态文件）：bootstrap：引入bootstrap目录，具体可以看看bootstrap目录中的_styles.scss、_variables.scsshorizon：引入horizon组件的静态文件包js：引入自定义的js文件_styles.scss：引入bootstrap、horizon目录中的样式文件，通过“@import “bootstrap/styles”;”其中styles指的是bootstrap目录中_styles.scss文件，同理horizon。_variables.scss：引入bootstrap、horizon目录中的定义的scss定义的变量文件，通过“@import “bootstrap/variables”;”其中variables指的是bootstrap目录中_variables.scss文件，同理horizon。 templates html模版文件：其实修改horizon的模版文件很简单，我只要按照上文中提到的horizon模版定义的路径，在自己的主题模版中再定义一遍就能覆盖，其实也不叫覆盖，就是在我的主题模版中一模一样的路径以及文件名定义一份，那么优先加载我定义的，当然前提是主题需要切换到我定义的主题上，不然还是不会加载的。以下目录的介绍不单单指的是当前主题中定义的，还包括horizon主题模版中这些目录包含的内容，如果我对这些模版有修改的需求，我只需要在这里定义一遍，切换到我定义的主题时，就能应用上。auth：horizon登录界面相关的模版文件header：horizon内页header样式文件，包括项目切换等。horizon：这个目录包括的东西比较多，包括内页左侧导航、form表单、table、model、tab等material：这里我不需要了，直接删除旧可以了 梳理了一遍，现在把bruce主题目录下面不需要的目录删除，添加自己需要的目录，具体目录结构如下：为了方便开发，我这里直接把auth、templates、horizon拷贝到bruce templates目录中，按照正常的开发来说，我需要重定制什么那么就把什么文件在主题中定义一遍，我这边为了方便直接把整个目录拷贝过来了。 12345cp -r /horizon.dev/horizon/templates/auth/cp -r /horizon.dev/openstack_dashboard/templates/header/cp -r /horizon.dev/horizon/templates/horizon/ 并且在static目录中新建了一个bruce目录用来放我的静态文件。在最外层_styles.scss、_variables.scss文件中引入bruce目录中styles、variables定义的内容。引入方式很简单，分别在最外层_styles.scss、_variables.scss文件增加以下内容： 12345_styles.scss：@import &quot;bruce/styles&quot;;_variables.scss：@import &quot;bruce/variables&quot;; 在运行命令：这里不再细说scss样式文件的开发，后续有时间在通过其他博文具体来说明。 12python manage.py collectstatic -cpython manage.py compress 把你新增的scss文件编译压缩。 最终你的目录结构看起来会是这个样子：.├── static│ ├── bootstrap│ ├── bruce│ ├── _styles.scss│ └── _variables.scss│ ├── horizon│ ├── _styles.scss│ └── _variables.scss└── templates ├── auth ├── header └── horizon 其中，在templates/horizon目录下面，我从openstack_dashboard/templates/horizon/_scripts.html文件拷贝了一份，现在你可以把你的js文件放在static/bruce/js目录中，通过_scripts.html文件加载进来，不过，通过这个文件加载的js文件时全局的，即各个页面只要按照horizon的html结构就能全部应用到，如果不想在各个页面使用，可以单独在html页面中引用，css文件也可以通过在html页面中单独引用，具体怎么引你可以看下_scripts.html引用方式即可。 五、登录界面开发之前提过，horizon登录界面的模版文件全部定义在auth目录中，现在我们简单进行开发， 打开：/themes/bruce/templates/auth/login.html 登录界面的入口文件 1234567891011121314&#123; % extends &quot;base.html&quot; % &#125;&#123; % load i18n % &#125;&#123; % block title % &#125;&#123; % trans &quot;Login&quot; % &#125;&#123; % endblock % &#125;&#123; % block body_id % &#125;splash&#123; % endblock % &#125;&#123; % block content % &#125; &#123; % include &apos;auth/_login.html&apos; % &#125;&#123; % endblock %&#125;&#123; % block footer % &#125; &#123; % include &apos;_login_footer.html&apos; % &#125;&#123; % endblock % &#125; 可以看到，这个文件继承自base.html,定义在horizon.dev/openstack_dashboard/templates目录中，base.html：文件定义了整个html的目录结构，如果你需要调整html结构，可以把这个文件复制到/themes/bruce/templates/目录中，如果登录界面的html结构和内页的结构不一样，可以重定义一个login_base.html,只要{ % extends “login_base.html” % }即可。这里同样我把这个文件复制了过来。为了说明，草率的进行了修改修改加了一个div： 12345&lt;body id=&quot;&#123; % block body_id % &#125;&#123; % endblock % &#125;&quot; ng-app=&apos;horizon.app&apos; ng-strict-di&gt; &lt;div style=&quot;background-color: #DE1426;&quot;&gt; Test &lt;/div&gt; ...... ￼可以看到生效了，看起来比较丑，哈哈，说明我们的结构修改生效了。接下来我们再来看下auth/_login.html，1234567&#123; % load i18n %&#125; &#123; % if &apos;is_modal&apos; in request.GET or &apos;is_modal&apos; in request.POST % &#125; &#123; % include &apos;auth/_login_modal.html&apos; % &#125;&#123; % else % &#125; &#123; % include &apos;auth/_login_page.html&apos; % &#125;&#123; % endif % &#125; 用样这个文件引入了_login_modal.html文件和_login_page.html文件，如果你觉的这样的引入层级太复杂了，也可以直接修改掉。 auth/_login_modal.html:定义登录表单,开开这个文件，可以看到它时继承自auth/_login_form.html文件，这个文件中详细定义了登录界面，修改如下：1234567&lt;div class=&quot;panel-heading&quot;&gt;&#123; % block login_header % &#125; &lt;h3 class=&quot;login-title&quot;&gt; &#123; % trans &apos;Log in&apos; % &#125;Hello World &lt;/h3&gt;&#123; % endblock % &#125;&lt;/div&gt; ￼简单吧，登录界面的修改就是这些auth/*.html页面中，具体就要看你需要修改成什么样子。## 五、header 修改好了，现在我们来看下登录进去之后header这块怎么来修改，同理：header html页面主要在/themes/bruce/templates/header目录中通过base.html：123&lt;div class=&apos;topbar&apos;&gt; &#123; % include &quot;header/_header.html&quot; % &#125;&lt;/div&gt; 可以得知_header.html是header模块的入口文件，打开/themes/bruce/templates/header/_header.html修改如下： 12&lt;nav class=&quot;navbar navbar-default navbar-fixed-top&quot; style=&quot;background-color: #3E3B3B;&quot;&gt;.... 效果如下：￼ 继续往下看，可以看到_header.html文件中引入 { % include “header/_brand.html” % }:没什么好讲，这个文件主要用来加载logo，如果你对logo的部署有所调整可以在这个文件中修改。 { % include “header/_context_selection.html” % }:该文件主要用来在定义项目／区域切换的样式：简单修改如下： 123&#123; % else % &#125;&lt;li class=&quot;dropdown&quot; style=&quot;background-color: #57b382;&quot;&gt;...... { % asset_img p8.png 图8 % }￼￼可以看到项目切换颜色发生了变化。在这个文件中通过{ % load context_selection % }自定义的标签引入了horizon.dev/openstack_dashboard/templatetags/context_selection.py 整个horizon项目中templatetags目录中定义的私有的django模版标签即自定义模版标签。通过引入这个文件，在_context_selection.html中使用的标签都可以在context_selection.py文件中找到他的实现。{ % show_overview % }：对应“def show_overview(context)”方法，并且可以根据这个方法得知它所使用的模版horizon.dev/openstack_dashboard/templates/context_selection/_overview.html，如果你想修改这个模版片段，原理都一样，那这个文件安相同的目录结构在我们的主题/themes/bruce/templates/context_selection/建立起来再进行修改即可，这里不再详细说明。{ % show_domain_list % }：修改原理同上{ % show_project_list % }：修改原理同上{ % show_region_list % }：修改原理同上 { % include “header/_user_menu.html” % }:主要用来显示右侧点击当前登录用户名的下拉列表框，包括帮助、主题切换、退出等功能简单修改如下： 12&#123; % else % &#125;&lt;li class=&quot;dropdown user-menu&quot; style=&quot;background-color: #57b382;&quot;&gt; 效果：￼￼ { % include “header/_region_selection.html” % }:用来定义区域选择，因为本地开发环境没有多区域，不能简单修改样式，但基本和上述一样进行修改即可。 如果你想在header下面添加面包屑，这一块horizon默认已经给我写好了一个样式，通过下面的修改很快就能实现一个简单样式的面包屑，当然样式就不咋的了，修改：/themes/bruce/templates/header/_header.html 12345......&lt;div style=&quot; margin-top: 43px; margin-left: 240px;&quot;&gt;&#123; % include &apos;horizon/common/_breadcrumb_nav.html&apos; % &#125;&lt;/div&gt;&#123; % endspaceless % &#125; ￼￼header的开发就讲到这里，其实都还比较简单。## 五、sidebar修改(侧边导航)根据/themes/bruce/templates/base.html 可知侧边导航入口文件为：{ % include ‘horizon/common/_sidebar.html’ % }12345......&#123; % block sidebar % &#125; &#123; % include &apos;horizon/common/_sidebar.html&apos; % &#125;&#123; % endblock % &#125;...... ok,我们打开/themes/bruce/templates/horizon/common/_sidebar.html 12345&#123; % load branding horizon i18n % &#125;&lt;div id=&apos;sidebar&apos; style=&quot;background: #353644;&quot;&gt; &#123; % horizon_nav % &#125;&lt;/div&gt; 那么在哪里定义了horizon_nav这个变量呢？可以看到它加载了{ % load branding horizon i18n % }，注意，这里有“horizon”这个文件指的是horizon.dev/horizon/templatetags/horizon.py，其中{ % horizon_nav % }标签通过文件中的”def horizon_nav(context):“函数方法定义，并且该函数方法指定了模版文件为horizon/_sidebar.html。如果需要对返回的数据格式有修改就需要改动这个文件，不建议直接修改，可以重构一个方法来进行修改合适。打开/themes/bruce/templates/horizon/_sidebar.html，没什么好讲都是html代码，其中导航就是通过for标签循环components变量加载出来的，直接进行修改就行了。简单的在： 1234567891011/themes/bruce/templates/horizon/common/_sidebar.html&#123; % load branding horizon i18n % &#125;&lt;div id=&apos;sidebar&apos; style=&quot;background: #43444C;&quot;&gt; &#123; % horizon_nav % &#125;&lt;/div&gt;/themes/bruce/templates/horizon/_sidebar.html在不同的&lt;li&gt;以及&lt;a&gt;便签添加了style=&quot;color: #fff&quot;style=&quot;background: #353644;&quot; 效果如下：￼￼ 六、page header 修改/themes/bruce/templates/base.html文件中包括了htmlhorizon/common/_page_header.html: 12345..... &#123; % block page_header % &#125; &#123; % include &quot;horizon/common/_page_header.html&quot; with title=page_title % &#125; &#123; % endblock % &#125; ...... 这个文件主要用来定义右侧页面用来显示当前plan名字位置区域，开打该文件：/themes/bruce/templates/horizon/common/_page_header.html 1234567891011&#123; % load i18n %&#125;&#123; % block page_header %&#125; &lt;div class=&apos;page-header&apos;&gt; &#123; % if actions %&#125; &lt;form class=&apos;actions_column pull-right&apos; action=&apos;&#123;&#123; url &#125;&#125;&apos; method=&quot;POST&quot;&gt; &#123; % csrf_token %&#125; &#123;&#123; actions &#125;&#125; &lt;/form&gt; &#123; % endif %&#125; &lt;/div&gt;&#123; % endblock %&#125; 修改为： 123456789101112131415&#123; % load i18n % &#125;&#123; % block page_header % &#125; &lt;div class=&apos;page-header&apos;&gt; &lt;div class=&quot;alert&quot; style=&quot;background-color:#bce8f1;border-color: #bce8f1;color: #31708f;&quot; role=&quot;alert&quot;&gt; BruceCloud 为您提供一种随时获取的、弹性的计算能力，这种计算能力的体现就是 &lt;em&gt;主机（Instance）&lt;/em&gt;。主机就是一台配置好了的服务器，它有您期望的硬件配置、操作系统和网络配置。通常情况下，您的请求可以在10秒到60秒的时间之内 完成，所以您完全可以动态地、按需使用计算能力。 &lt;/div&gt; &#123; % if actions % &#125; &lt;form class=&apos;actions_column pull-right&apos; action=&apos;&#123;&#123; url &#125;&#125;&apos; method=&quot;POST&quot;&gt; &#123; % csrf_token % &#125; &#123;&#123; actions &#125;&#125; &lt;/form&gt; &#123; % endif % &#125; &lt;/div&gt;&#123; % endblock % &#125; 效果：{ % asset_img p12.png 图12 % }￼￼ 六、footer 修改/themes/bruce/templates/base.html文件中包括了html_footer.html : 123&#123; % block footer % &#125; &#123; % include &quot;_footer.html&quot; % &#125;&#123; % endblock % &#125; 该文件默认放在horizon.dev/openstack_dashboard/templates/_footer.html目录下，老方法，拷贝一份到/themes/bruce/templates/目录下，打开： 123&#123; % comment % &#125; A simple placeholder template for custom global footer content&#123; % endcomment % &#125; 默认控制为不显示出来，不细究，反正比较简单。 六、messages 修改/themes/bruce/templates/base.html文件中包括了htmlhorizon/_messages.html: 1234......&lt;div id=&apos;main_content&apos; style=&quot;margin-top: -90px;&quot;&gt; &#123; % include &quot;horizon/_messages.html&quot; % &#125;...... 打开：/themes/bruce/templates/horizon/_messages.html： 12345678910&#123; % for message in messages % &#125; &#123; % if &quot;info&quot; in message.tags % &#125; &lt;div class=&quot;alert alert-info alert-dismissable fade in&quot;&gt; &lt;a class=&quot;close&quot; data-dismiss=&quot;alert&quot; href=&quot;#&quot;&gt; &lt;span class=&quot;fa fa-times&quot;&gt;&lt;/span&gt; &lt;/a&gt; &lt;p&gt;&lt;strong&gt;&#123;% trans &quot;Info: &quot; % &#125;&lt;/strong&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;/div&gt; &#123; % endif % &#125;...... 文件中定义不同消息类型显示的样式。需要修改的直接改这个文件就可以了。 七、project/instances修改原理很简单，在每个模块下面都有一个templates，当然不直接修改这个目录下面的模版文件，我们把整个模版目录拷贝到我们的主题模版目录下面来进行修改，例如：建立如下目录结构：horizon.dev/openstack_dashboard/themes/bruce/templates/project拷贝：cp -r ../../../../dashboards/project/instances/templates/instances/ ./好了，现在我们开始修改我们主机模版目录下面的instances模版样式文件：修改云主机下拉列表页面，打开目录：themes/bruce/templates/project/instances/index.html 123456789101112&#123; % extends &apos;base.html&apos; % &#125;&#123; % load i18n % &#125;&#123; % block title % &#125;&#123; % trans &quot;Instances&quot; % &#125;&#123; % endblock % &#125;&#123; % block main % &#125; &lt;div class=&quot;jumbotron&quot;&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;p&gt;...&lt;/p&gt; &lt;p&gt;&lt;a class=&quot;btn btn-primary btn-lg&quot; href=&quot;#&quot; role=&quot;button&quot;&gt;Learn more&lt;/a&gt;&lt;/p&gt;&lt;/div&gt; &#123;&#123; table.render &#125;&#125;&#123; % endblock % &#125; 效果： ￼￼ 修改table样式：类似table、modal、form样式的定义不在instances这个目录下面，这个目录下定义的都是instances所特有的样式结构；table、modal、form这些样式的定义往往是全局的，基本都是放在themes/bruce/templates/horizon/common目录下面，例如：themes/bruce/templates/horizon/common/_data_xxx.html用来定义table的样式；themes/bruce/templates/horizon/common/_form_xxx.html定义form表单；themes/bruce/templates/horizon/common/_modal_xxx.html定义modal表单；定义弹出框；……其他模块的修改都是类似的，例如概况页面、云硬盘等。 ￼ 主题切换回default：￼￼ 对原来主题没有任何影响，不得不佩服OpenStack Horizon代码架构越来越好了， 好了OpenStack Horizon的主题开发就讲到这里，后续将推出更多这样的文章！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OpenStack Horizon 主题下载]]></title>
      <url>%2F2017%2F02%2F26%2F2017022602%2F</url>
      <content type="text"><![CDATA[一、写在前面这篇文章主要介绍基于OpenStack Mitaka Horizon版本开发的主题Bruce，整个主题开发基本没有修改Horizon原有的任何代码，所有的主题代码都在horizon/openstack_dashboard/themes/bruce目录中，一方面更好的兼容openstack horion以便后续版本升级，另一方面，方便大家学习。如果转载，请保留作者信息。邮箱地址：jpzhang.ht@gmail.com主题下载地址： 二、OpenStack Bruce 主题介绍####目录结构：horizon/openstack_dashboard/themes.├── bruce│ ├── static│ └── templates├── default│ ├── bootstrap│ └── horizon├── demo│ ├── help│ ├── html│ ├── javascripts│ ├── patches│ └── styles└── material ├── static └── templates bruce代码主题包存放在bruce目录中。static目录用来存放所有的静态文件包括CSS、JS等，templates目录存放所有的主题模版。这里不在具体详细的解释开发步骤， Bruce 主题介绍：1、系统登录界面 登录界面下方可以自由切换喜欢的背景图片 2、项目概况 ￼￼ 登录进来后项目概况页面，左侧导航通过OpenStack 机制自动加载出来， 可以根据用户个人习惯，通过单机按钮展开或者缩紧， 右侧齿轮样子的图标可以根据喜好西游配置主题颜色风格 页面主要显示项目可用配置的使用情况，以及最近的项目操作记录，当然，操作记录这块底层并没有实现，要实现的话简单的方式就是在API 包里面通过装饰器的方式往数据库记录用户操作* 可以自由在openstack 原生主题切换3、项目云主机列表￼￼这一块基本保持openstack 原有的样式风格，只不过增加了云主机的介绍相关的信息。4、云主机详情￼￼同样，保持原生样式结构，只不过对一些信息点进行了高粱处理，不过您们有时间可以对这块的内容进行重新排版，当前的样式比较浪费空间。5、项目云硬盘 6、项目镜像列表 7、系统概况 8、系统虚拟机管理器 其他模块页面基本相识，这里不再一一展开来讲，感兴趣的可以通过以下的方式下载学习。 9、静态模版样式包： ￼ 三、部署通过下的方式获取代码包，通过 python manage.py runserver 运行：vi horizon-bruce/horizon/openstack_dashboard/local/ local_settings.py12OPENSTACK_HOST=&quot;192.168.31.235&quot;OPENSTACK_KEYSTONE_URL=&quot;http://192.168.31.235:5000/v3&quot; 配置您的openstack 控制节点地址，以及keystone地址，如果在同一个节点上地址就是一样的。 重新生成静态文件到/stack 目录下sudo python manage.py collectstatic -c 运行时候提示输入 “yes” 压缩静态问价：sudo python manage.py compress 通过Apache运行：通过mv 命令备份原先的horizon包，然后把下载下来新的horizon包放到该位置上，修改如下： vi horizon-bruce/horizon/openstack_dashboard/local/ local_settings.py12OPENSTACK_HOST=&quot;192.168.31.235&quot;OPENSTACK_KEYSTONE_URL=&quot;http://192.168.31.235:5000/v3&quot; 配置您的openstack 控制节点地址，以及keystone地址，如果在同一个节点上地址就是一样的。 重新生成静态文件到/stack 目录下sudo python manage.py collectstatic -c 运行时候提示输入 “yes” 压缩静态问价：sudo python manage.py compress 修改apache配置：vi /etc/apache2/sites-available/horizon.conf 路径可能有所不一样，应为我这里是devstack起的apache。主要是将“/dashboard/”修改成“/”根目录“/dashboard/“ ＝》 “/project/“1234WSGIScriptAlias / /home/devstack.mitaka/horizon/openstack_dashboard/wsgi/django.wsgiAlias /media /home/devstack.mitaka/horizon/openstack_dashboard/staticAlias /static /home/devstack.mitaka/horizon/staticRedirectMatch &quot;^/$&quot; &quot;/project/&quot; 重启apache服务即可 四、下载您的小额赞助，鼓励作者写出更好的主题，让更多的OpenStack开发者、创业公司能够更专注底层虚拟化、存储、网络，不必在担心horizon的优化等。 基本版本下载：包括上述描述的所有界面功能，但不提供静态主题包，扫一扫下方二维码，完成支付，并把截图发送给QQ：3477447625，将获取百度云下载密码，百度云下载地址：链接: http://pan.baidu.com/s/1slR9lHr 完整版本下载：包括基础版所有界面功能，并附加一个静态完整主题包(horizon/openstack_dashboard/themes/demo)，方便您后续按照需求继续完善开发。扫一扫下方二维码，完成支付，并把截图发送给QQ：3477447625，将获取百度云下载密码，百度云下载地址：链接: http://pan.baidu.com/s/1pLTFhSR￼]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[以此为点，从新起航]]></title>
      <url>%2F2017%2F02%2F26%2F2017022601%2F</url>
      <content type="text"><![CDATA[以此为点，记录下点点滴滴]]></content>
    </entry>

    
  
  
</search>
